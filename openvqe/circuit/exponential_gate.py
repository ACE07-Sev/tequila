"""
Exponential Gates which are generated by (anti-)hermitian Operators
"""
from openvqe import typing
from openvqe import OpenVQEException
from openvqe.hamiltonian import QubitHamiltonian
from openvqe.circuit import QCircuit, gates
from openvqe.circuit._gates_impl import RotationGateImpl
from openvqe.tools.convenience import number_to_string
from openvqe import numpy
from openvqe.circuit.compiler import change_basis
from random import shuffle


class DecompositionABC:
    """
    implements a call operator which takes an (anti-)hermitian operator outputs
    a decomposed unitary
    """

    def __call__(self, generator: QubitHamiltonian, *args, **kwargs):
        raise OpenVQEException("Overwrite this")


class ExponentialPauliGate(RotationGateImpl):
    """
    Same convention as for rotation gates:
    Exp(-i angle/2 * paulistring)
    """

    def __init__(self, paulistring, angle: float, control: typing.List[int] = None, frozen: bool = False):
        self.paulistring = paulistring
        self.parameter = angle
        self.target = [t[0] for t in paulistring]
        self.control = control
        self.frozen = frozen

    def __str__(self):
        return "Exp(" + number_to_string(-self.parameter * 1.0j) + "/2" + str(self.paulistring) + ")" + str(self.target)

    def decompose(self):
        return self.compile_exponential_pauli_gate(paulistring=self.paulistring, angle=self.parameter)

    @staticmethod
    def compile_exponential_pauli_gate(paulistring, angle) -> QCircuit:
        """
        Returns the circuit: exp(i*angle*paulistring)
        primitively compiled into X,Y Basis Changes and CNOTs and Z Rotations
        :param paulistring: The paulistring in given as tuple of tuples (openfermion format)
        like e.g  ( (0, 'Y'), (1, 'X'), (5, 'Z') )
        :param angle: The angle which parametrizes the gate -> should be real
        :returns: the above mentioned circuit as abstract structure
        """

        if not numpy.isclose(numpy.imag(angle), 0.0):
            raise OpenVQEException("angle is not real, angle=" + str(angle))

        circuit = QCircuit()

        # the general circuit will look like:
        # series which changes the basis if necessary
        # series of CNOTS associated with basis changes
        # Rz gate parametrized on the angle
        # series of CNOT (inverted direction compared to before)
        # series which changes the basis back
        ubasis = QCircuit()
        ubasis_t = QCircuit()
        cnot_cascade = QCircuit()
        reversed_cnot = QCircuit()

        last_qubit = None
        previous_qubit = None
        for pq in paulistring:
            pauli = pq[1]
            qubit = [pq[0]]  # wrap in list for targets= ...

            # see if we need to change the basis
            axis = 2
            if pauli.upper() == "X":
                axis = 0
            elif pauli.upper() == "Y":
                axis = 1
            ubasis *= change_basis(target=qubit, axis=axis)
            ubasis_t *= change_basis(target=qubit, axis=axis, daggered=True)

            if previous_qubit is not None:
                cnot_cascade *= gates.X(target=qubit, control=previous_qubit)
            previous_qubit = qubit
            last_qubit = qubit

        reversed_cnot = cnot_cascade.dagger()

        # assemble the circuit
        circuit *= ubasis
        circuit *= cnot_cascade
        circuit *= gates.Rz(target=last_qubit, angle=angle)
        circuit *= reversed_cnot
        circuit *= ubasis_t

        return circuit


class DecompositionFirstOrderTrotter:

    def __init__(self, steps: int, threshold: float = 0.0, join_components: bool = False,
                 randomize_component_order: bool = False, randomize: bool = False, t: float = 1.0):
        """
        The Decomposition module implements a call operator which decomposes a set of QubitHamiltonians
         into ExponentialPauligates
        See the __call__ implementation for more
        :param steps: Trotter Steps
        :param threshold: neglect terms in the given Hamiltonians if their coefficients are below this threshold
        :param join_components: The QubitHamiltonians in the list given to __call__ are jointly trotterized
        :param randomize_component_order: randomize the component order before trotterizing
        :param randomize: randomize the trotter decomposition of each component
        this means the trotterization will be:
        Trotter([H_0, H_1]) = Trotter(exp(i(H_0+H_1)t)
        otherwise it will be
        Trotter([H_0, H_1]) = Trotter(exp(i(H_0))Trotter(epx(iH_1t))
        """
        self.steps = steps
        self.threshold = threshold
        self.join_components = join_components
        self.randomize_component_order = randomize_component_order
        self.randomize = randomize
        self.t = t

    def __call__(self, generators: typing.List[QubitHamiltonian], *args, **kwargs) -> QCircuit:
        """
        See __init___ for effect of several parameters
        :param generators: Generators given as a list of QubitHamiltonians [H_0, H_1, ...]
        :return: Trotter(exp(iH_0t))*Trotter(exp(iH_1t))*... or Trotter(exp(i(H_0+H_1+...)t) depeding on self.join_components
        """
        result = QCircuit()
        if self.join_components:
            for step in range(self.steps):
                if self.randomize_component_order:
                    shuffle(generators)
                    for g in generators:
                        result += self.compile(generator=g, steps=1, factor=1.0 / self.steps, randomize=self.randomize)
        else:
            if self.randomize_component_order:
                shuffle(generators)
            for g in generators:
                result += self.compile(generator=g, randomize=self.randomize)
            return result

    def compile(self, generator: QubitHamiltonian, steps: int = None, factor: float = 1.0, randomize: bool = False):
        if steps is None:
            steps = self.steps
        assert (generator.is_hermitian())
        circuit = QCircuit()
        factor = factor / steps
        for index in range(steps):
            keys = generator.keys()
            if randomize:
                keys = [k for k in keys]
                shuffle(keys)
            for key in keys:
                value = generator[key]
                # don't make circuit for too small values
                if key != () and not numpy.isclose(value, 0.0, atol=self.threshold):
                    circuit += ExponentialPauliGate(paulistring=key, angle=value * factor)

        return circuit
