"""
Exponential Gates which are generated by (anti-)hermitian Operators
"""
from openvqe import typing
from openvqe import OpenVQEException
from openvqe.hamiltonian import QubitHamiltonian
from openvqe.circuit import QCircuit, gates
from openvqe.circuit._gates_impl import RotationGateImpl
from openvqe.tools.convenience import number_to_string
from openvqe import numpy
from openvqe.circuit.compiler import change_basis


class DecompositionABC:
    """
    implements a call operator which takes an (anti-)hermitian operator outputs
    a decomposed unitary
    """

    def __call__(self, generator: QubitHamiltonian, *args, **kwargs):
        raise OpenVQEException("Overwrite this")


class ExponentialPauliGate(RotationGateImpl):
    """
    Same convention as for rotation gates:
    Exp(-i angle/2 * paulistring)
    """

    def __init__(self, paulistring, angle: float, control: typing.List[int] = None, frozen: bool = False):
        self.paulistring = paulistring
        self.parameter = angle
        self.target = [t[0] for t in paulistring]
        self.control = control
        self.frozen = frozen

    def __str__(self):
        return "Exp(" + number_to_string(-self.parameter * 1.0j) + "/2" + str(self.paulistring) + ")" + str(self.target)

    def decompose(self):
        return self.compile_exponential_pauli_gate(paulistring=self.paulistring, angle=self.parameter)

    @staticmethod
    def compile_exponential_pauli_gate(paulistring, angle) -> QCircuit:
        """
        Returns the circuit: exp(i*angle*paulistring)
        primitively compiled into X,Y Basis Changes and CNOTs and Z Rotations
        :param paulistring: The paulistring in given as tuple of tuples (openfermion format)
        like e.g  ( (0, 'Y'), (1, 'X'), (5, 'Z') )
        :param angle: The angle which parametrizes the gate -> should be real
        :returns: the above mentioned circuit as abstract structure
        """

        if not numpy.isclose(numpy.imag(angle), 0.0):
            raise OpenVQEException("angle is not real, angle=" + str(angle))

        circuit = QCircuit()

        # the general circuit will look like:
        # series which changes the basis if necessary
        # series of CNOTS associated with basis changes
        # Rz gate parametrized on the angle
        # series of CNOT (inverted direction compared to before)
        # series which changes the basis back
        ubasis = QCircuit()
        ubasis_t = QCircuit()
        cnot_cascade = QCircuit()
        reversed_cnot = QCircuit()

        last_qubit = None
        previous_qubit = None
        for pq in paulistring:
            pauli = pq[1]
            qubit = [pq[0]]  # wrap in list for targets= ...

            # see if we need to change the basis
            axis = 2
            if pauli.upper() == "X":
                axis = 0
            elif pauli.upper() == "Y":
                axis = 1
            ubasis *= change_basis(target=qubit, axis=axis)
            ubasis_t *= change_basis(target=qubit, axis=axis, daggered=True)

            if previous_qubit is not None:
                cnot_cascade *= gates.X(target=qubit, control=previous_qubit)
            previous_qubit = qubit
            last_qubit = qubit

        reversed_cnot = cnot_cascade.dagger()

        # assemble the circuit
        circuit *= ubasis
        circuit *= cnot_cascade
        circuit *= gates.Rz(target=last_qubit, angle=angle)
        circuit *= reversed_cnot
        circuit *= ubasis_t

        return circuit


class DecompositionFirstOrderTrotter:

    def __init__(self, steps: int, threshold: float = 0.0, randomize: bool = False):
        self.steps = steps
        self.threshold = threshold
        self.randomize = randomize

    def __call__(self, generators: typing.List[QubitHamiltonian], *args, **kwargs) -> QCircuit:
        result = QCircuit()
        for g in generators:
            result += self.compile(generator=g)
        return result

    def compile(self, generator: QubitHamiltonian):
        assert (generator.is_hermitian())
        t = 1.0
        circuit = QCircuit()
        factor = t / self.steps
        for index in range(self.steps):
            items = generator.items()
            for key, value in items:
                if key != () and not numpy.isclose(value, 0.0, atol=self.threshold):
                    # don't make circuit for too small values
                    circuit += ExponentialPauliGate(paulistring=key, angle=value * factor)

        return circuit
