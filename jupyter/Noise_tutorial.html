<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Noise in Tequila &#8212; tequila 0.0.3 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="State preparation algorithm tutorial" href="StatePreparation_tutorial.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          Tequila</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href=".././tequila_presentation.html">Overview</a></li>
                <li><a href=".././README.html">Installation</a></li>
                <li><a href=".././package/index.html">API</a></li>
                <li><a href="https://github.com/aspuru-guzik-group/tequila">GitHub</a></li>
                <li><a href=".././tutorials.html">Tutorials</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Tequila</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#quantum-backends">Quantum Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#quantumchemistry">QuantumChemistry:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#getting-started">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#dependencies">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#troubleshooting">Troubleshooting</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../package/index.html">Tequila Library Reference</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="StatePreparation_tutorial.html" title="Previous Chapter: State preparation algorithm tutorial"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; State prepara...</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/jupyter/Noise_tutorial.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="noise-in-tequila">
<h1>Noise in Tequila<a class="headerlink" href="#noise-in-tequila" title="Permalink to this headline">¶</a></h1>
<p>Hello, and welcome to this tutorial on simulating circuit noise in
Tequila! In this tutorial, we will briefly detail what quantum noise is,
its mathematical modeling, and how specific popular simulation packages
handle noisy simulation, before diving in to building Tequila
<code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code>s and applying them to sampling different circuits.</p>
<p>#</p>
<center><p>What is noise?</p>
</center><p>In case you need a quick refresher: Real quantum systems undergo the
effects of noise, a catch-all term for ‘anything the user didn’t ask the
computer to do’. Such noise can be caused by a number of physical
processes, including but not limited to:</p>
<ul class="simple">
<li><p><strong>Thermal fluctuations</strong></p></li>
<li><p><strong>Interaction with the environment</strong></p></li>
<li><p><strong>Uncontrolled interaction between qubits (cross-talk)</strong></p></li>
<li><p><strong>Imperfections in gate implementation</strong></p></li>
</ul>
<p>#</p>
<center><p>How is noise represented mathematically?</p>
</center><p>Commonly, the effects of noise on quantum systems are treated as the
evolution of the system’s density matrix under Krauss maps. Krauss maps
are mappings of the form
<span class="math notranslate nohighlight">\(A:\rho\rightarrow\rho'=\sum_{i}A_i\rhoA_{i}^{\dagger}\)</span>, where
<span class="math notranslate nohighlight">\(\sum_{i}A_iA_{i}^{\dagger}=I\)</span>. These Krauss maps are
parametrized, in general by probabilities.</p>
<p>For example, bit flip noise – which takes qubits from the 0 to the 1
state and vice versa– is a krauss map with two operators, and a single
probabilistic parameter, p. The operators are:</p>
<div class="math notranslate nohighlight">
\[A_0 = \sqrt{1-p} I,  A_1 = \sqrt{p} X\]</div>
<p><strong>Note that the square root is present, so that bit flip map is:</strong></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}A_{bf}(p): \rho \rightarrow (1-p) * I\rho I + p * X\rho X\\other noise operations may be defined similarly.\end{aligned}\end{align} \]</div>
<p><strong>Note that such krauss operators may only affect subsystems of the
system;</strong> one can have a single qubit undergo bit-flip noise in an 8
qubit state. In such cases, the krauss maps are merely the 1-qubit maps
tensored with the identity on all other qubits. Multi-qubit krauss
operators will involve tensor products of single qubit krauss operators.</p>
<p>For example, the 2-qubit bit flip krauss map has 4 operators:</p>
<div class="math notranslate nohighlight">
\[A_{00}=(1-p)I\otimes I, A_{01}=\sqrt{p-p^2}I\otimes X,A_{10}=\sqrt{p-p^2}X \otimes I,A_{11}=pX\otimes X\]</div>
<p>Which are just all the tensor products of <span class="math notranslate nohighlight">\(A_{0}\)</span> and
<span class="math notranslate nohighlight">\(A_{1}\)</span>.</p>
<p>#</p>
<center><ol class="arabic" start="3">
<li><p>How is noise simulated?</p>
</center></li>
</ol>
<p>Different simulation packages handle noise in radically different ways.</p>
<p><em>Cirq</em> and <em>Qulacs</em>, for example, use noise channels, parametrized
operations which are inserted into circuits the same way regular,
unitary gates are.</p>
<p><em>Pyquil</em> asks its users to define noisy gate operations, and then
instantiate those.</p>
<p><em>Qiskit</em>, meanwhile, simply takes a dictionary-like object as an
argument to its simulator, and applies the noise on the user-chosen
gates.</p>
<p>In tequila, we try to hew toward making users write as few lines of code
as possible. We therefore implement a simple framework for the
application of noise, meant to be compatible with all our supported
platforms. To do this, we make a few assumptions:</p>
<ol class="arabic simple">
<li><p>If noise is present, any gate may be affected by noise.</p></li>
<li><p>The noise that affects 1..k..n-qubit gates is independent of the
noise on 1…k-1,k+1…n qubit gates.</p></li>
<li><p>Noise probabilities are independent of position in the circuit.</p></li>
<li><p>The number of qubits involved in a gate, not the operation performed,
dictates what noises may occur.</p></li>
</ol>
<p>#</p>
<center><p>Noise in Tequila: Overview</p>
</center><p>noise in Tequila is centered upon the <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> class, itself used
to store and combine <code class="docutils literal notranslate"><span class="pre">QuantumNoise</span></code> objects. Each <code class="docutils literal notranslate"><span class="pre">QuantumNoise</span></code>
internally designates what operation it will perform, with what
probability (or probabilities), and on how many qubits. Only at the time
of translation to a backend – or in the case of <em>Qiskit</em>, at time of
simulation – do<code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code>s and simulateables – circuits,
ExpectationValues, Objectives – interact.</p>
<p>Tequila at present supports six common quantum noise operations, all of
which can at present be employed by all the noise-supporting simulation
backgrounds. These six operations are:</p>
<ol class="arabic simple">
<li><p>Bit flips, a probabilistic application of pauli X;</p></li>
<li><p>Phase flips, a probablistic application of pauli Z;</p></li>
<li><p>Amplitude damps, which take qubits in state |1&gt; to |0&gt;;</p></li>
<li><p>Phase damps, which are a different formalization of the phase flip;</p></li>
<li><p>Phase-Amplitude damps, which simultaneously perform said operations;</p></li>
<li><p>(Symmetric) depolarizing, which (equi)probabilistically performs
pauli X, Y, and Z.</p></li>
</ol>
<p>in Tequila, custom members of the <code class="docutils literal notranslate"><span class="pre">QuantumNoise</span></code> class are not
possible, and so they should be initialized by the constructor function
for each supported channel, which creates a <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> containing
one operation. all six of which are shown in the import statement below.</p>
<p><code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code>s combine with eachother through addition, creating a
new <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> with all the operations of the two summands. Note
that in those simulators which employ noise channels, the order of the
noises in the noise model will dictate the order of application in the
circuit; users should be mindful of this.</p>
<p>To use a <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> to apply noise, one may provide a noise model to
the <em>tq.compile</em>, <em>tq.simulate</em>, and optimization calls like
<em>tq.minimize</em>, through the keyword <code class="docutils literal notranslate"><span class="pre">noise=my_noise_model</span></code>. Noise is
only supported when sampling; if in the above functions the keyword
<em>samples</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (defaullt), noise cannot function.</p>
<p>additionally, Tequila supports the use of device-noise-emulation for
those backends which allow the emulation of specific real devices. If in
compilation, simulation, or optimization, emulated backends have been
selected (such as ‘fake_vigo’, for IBMQ), the known noise of this
device may be employed. In these cases, the keyword assignment
<em>noise=’device’</em> should be used, if these known noise models are
desired.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### first, we import tequila!</span>
<span class="kn">import</span> <span class="nn">tequila</span> <span class="k">as</span> <span class="nn">tq</span>
<span class="kn">from</span> <span class="nn">tequila.circuit.noise</span> <span class="kn">import</span> <span class="n">BitFlip</span><span class="p">,</span><span class="n">PhaseFlip</span><span class="p">,</span><span class="n">AmplitudeDamp</span><span class="p">,</span><span class="n">PhaseDamp</span><span class="p">,</span><span class="n">PhaseAmplitudeDamp</span><span class="p">,</span><span class="n">DepolarizingError</span>
</pre></div>
</div>
<p>We will first examine bit flip noise on a simple circuit with a simple
Hamiltonian.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">paulis</span><span class="o">.</span><span class="n">Qm</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">### this hamiltonian is 0 for a qubit that is 0, and 1 for a qubit that is 1.</span>
<span class="n">U</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">O1</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;simulating: &#39;</span><span class="p">,</span><span class="n">H</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;acting on: &#39;</span><span class="p">)</span>
<span class="n">tq</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
</pre></div>
</div>
<p>Say that we wanted a noise model where 1-qubit gates and 2-qubit gates
undergo bit flips, but with different probabilities.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bf_1</span><span class="o">=</span><span class="n">BitFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">bf_2</span><span class="o">=</span><span class="n">BitFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> objects, like those initialized above, can be combined
into new <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code>s by simple addition.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_nm</span><span class="o">=</span><span class="n">bf_1</span><span class="o">+</span><span class="n">bf_2</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;applying:&#39;</span><span class="p">,</span><span class="n">my_nm</span><span class="p">)</span>
</pre></div>
</div>
<p>we will now sample our <code class="docutils literal notranslate"><span class="pre">Objective</span></code> O1, both with and without noise.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">E</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O1</span><span class="p">)</span>
<span class="c1">### noise models are fed to tequila functions with the noise keyword.</span>
<span class="n">E_noisy</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O1</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">my_nm</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Without noise, E =&#39;</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;With noise, E =&#39;</span><span class="p">,</span><span class="n">E_noisy</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Because noise is stochastic, results may vary wildly if the number of
samples is low.</strong></p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;round&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;sampling with 5 samples, E = &#39;</span><span class="p">,</span> <span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O1</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">my_nm</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the <em>BitFlip</em> functions returned applicable <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code>s
in their own right:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">E_1_only</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O1</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">bf_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;With 1-qubit noise only, E =&#39;</span><span class="p">,</span><span class="n">E_1_only</span><span class="p">)</span>
<span class="n">E_2_only</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O1</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">bf_2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;With 2-qubit noise only, E =&#39;</span><span class="p">,</span><span class="n">E_2_only</span><span class="p">)</span>
</pre></div>
</div>
<p>Below, we demonstrate the effects of the ordering of the noise
operations applied.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">amp</span><span class="o">=</span><span class="n">AmplitudeDamp</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">bit</span><span class="o">=</span><span class="n">BitFlip</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">forward</span><span class="o">=</span><span class="n">amp</span><span class="o">+</span><span class="n">bit</span>
<span class="n">backward</span><span class="o">=</span><span class="n">bit</span><span class="o">+</span><span class="n">amp</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">paulis</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">O</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>

<span class="n">E_1</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">forward</span><span class="p">)</span>
<span class="n">E_2</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">O</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">backward</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;amplitude damping before bit flip leads to E = &#39;</span><span class="p">,</span><span class="n">E_1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;amplitude damping after bit flip leads to E = &#39;</span><span class="p">,</span><span class="n">E_2</span><span class="p">)</span>
</pre></div>
</div>
<p>Tequila will <em>always</em> attempt to apply noise to the circuit <em>in the
order each noise was added to the noise model</em>. Some backends have
behavior which is harder to control than others, but in general, this
order will be preserved.</p>
<p>Below, we will optimize a noisy circuit.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Consider the 1-qubit expectation value,
<span class="math notranslate nohighlight">\(&lt;0|U^{\dagger}\hat{Y}U|0&gt;\)</span>, with <span class="math notranslate nohighlight">\(U=HRz(\theta)H\)</span>. In the
absence of noise, this expectation value just yields
<span class="math notranslate nohighlight">\(Sin(\theta)\)</span>. This circuit therefore has a minimum at
<span class="math notranslate nohighlight">\(\theta=-\pi\)</span>. We can minimize this circuit under phase flip noise
– which is probabilistic application of pauli Z – and see what
happens!</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span><span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">paulis</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">O</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>

<span class="c1">### we pick a random, small probability to apply noise</span>
<span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
<span class="n">NM</span><span class="o">=</span><span class="n">PhaseFlip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;optimizing expectation value with phase flip probability </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="n">result</span><span class="o">=</span><span class="n">tq</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="o">=</span><span class="n">O</span><span class="p">,</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span><span class="n">initial_values</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">},</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;adam&#39;</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span><span class="n">noise</span><span class="o">=</span><span class="n">NM</span><span class="p">,</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">result</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>The final energy is not -1.0, because the application of noise leads the
expected output to be <span class="math notranslate nohighlight">\((-1+2*p)^{3} Sin(\theta)\)</span>. One sees that
this is approximately the value reached by minimizing <span class="math notranslate nohighlight">\(\theta\)</span>.
Because the number of samples is not infinite, the ‘expected’ best
energy may be exceeded:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">energy</span>
<span class="n">best</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;best energy: &#39;</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;expected best &#39;</span><span class="p">,</span><span class="n">best</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="this-concludes-our-brief-tutorial-on-noise-stay-tuned-and-up-to-date-for-more-exciting-noise-features-in-the-future">
<h2>This concludes our brief tutorial on Noise. Stay tuned (and up to date) for more exciting noise features in the future!<a class="headerlink" href="#this-concludes-our-brief-tutorial-on-noise-stay-tuned-and-up-to-date-for-more-exciting-noise-features-in-the-future" title="Permalink to this headline">¶</a></h2>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020, Matter Lab.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>