<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Single-qubit classifier with data re-uploading tutorial &#8212; tequila 0.0.3 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tequila tutorial: raw state preparation algorithm" href="Tutorial_state_prep.html" />
    <link rel="prev" title="Tequila Tutorial:" href="SingleQubitClassifier.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          Tequila</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href=".././tequila_presentation.html">Overview</a></li>
                <li><a href=".././README.html">Installation</a></li>
                <li><a href=".././package/index.html">API</a></li>
                <li><a href="https://github.com/aspuru-guzik-group/tequila">GitHub</a></li>
                <li><a href=".././tutorials.html">Tutorials</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Tequila</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#quantum-backends">Quantum Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#quantumchemistry">QuantumChemistry:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#getting-started">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#dependencies">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#troubleshooting">Troubleshooting</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../package/index.html">Tequila Library Reference</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="SingleQubitClassifier.html" title="Previous Chapter: Tequila Tutorial:"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Tequila Tutorial:</span>
    </a>
  </li>
  <li>
    <a href="Tutorial_state_prep.html" title="Next Chapter: Tequila tutorial: raw state preparation algorithm"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Tequila tutor... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/jupyter/SingleQubitClassifier_tutorial.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="single-qubit-classifier-with-data-re-uploading-tutorial">
<h1>Single-qubit classifier with data re-uploading tutorial<a class="headerlink" href="#single-qubit-classifier-with-data-re-uploading-tutorial" title="Permalink to this headline">¬∂</a></h1>
<p>This tutorial shows: - How to construct a fidelity cost function for an
optimization problem - How to construct a quantum classifier with one
qubit</p>
<p>Based on <a class="reference external" href="https://quantum-journal.org/papers/q-2020-02-06-226/">Data re-uploading for a universal quantum
classifier</a>, A.
P√©rez-Salinas, A. Cervera-Lierta, E. Gil-Fuster, and J. I. Latorre,
<em>Quantum **4*</em>, 226 (2020)*.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tequila</span> <span class="k">as</span> <span class="nn">tq</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">random</span>
<span class="kn">import</span> <span class="nn">time</span>
</pre></div>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¬∂</a></h2>
<p>Single-qubit operations are just rotations on the Bloch sphere. A
collection of single-qubit rotations can be reduced to a single one by
combining their angles: you can always move from one point to another on
the Bloch sphere with a single operation.</p>
<p>Because of this property, a single-qubit classifier with simple
parameterized rotations can not treat complex data. Even if it succeeds
to classify one data point, it will probably misclassify the others
since rotational angles have been only adapted to one particular point.
To circumvent this limitation one can introduce the data points into
these angles, so each rotation will be data point-dependent. This
methodology is called data re-uploading and it can be shown that a
single-qubit classifier can be universal using this technique.</p>
<p>The strategy to train this single-qubit classifier is the following.
Given a problem with ùëõn classes, we choose ùëõn vectors on the Bloch
sphere. Then, we train the classifier by constructing a cost function
that adds penalties if the final state of the classifier is far from the
target state that corresponds to its class.</p>
<p>The single-qubit classifier circuit is divided into layers. Each layer
comprises single-qubit rotations that encode a data training point and
parameters to be optimized.</p>
<div class="math notranslate nohighlight">
\[L\left(\vec{x};\vec{\theta}_{i}\right) = U\left(\vec{x}\right)U\left(\vec{\theta}_{i}\right)\]</div>
<p>By considering more layers, the final state of the classifier will have
a richer structure in terms of the data point <span class="math notranslate nohighlight">\(\vec{x}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathcal{U}_{class}\left(\vec{x};\vec{\theta}_{1},\vec{\theta}_{2},...,\vec{\theta}_{l}\right) = L\left(\vec{x};\vec{\theta}_{1}\right)L\left(\vec{x};\vec{\theta}_{2}\right)\cdots L\left(\vec{x};\vec{\theta}_{l}\right)\]</div>
<p>We will run a <span class="math notranslate nohighlight">\(\mathcal{U}_{class}\)</span> for each training point
<span class="math notranslate nohighlight">\(\vec{x}\)</span>, but the parameters <span class="math notranslate nohighlight">\(\vec{\theta}\)</span> are the same.
These are the variables to be optimized classically through the cost
function.</p>
</div>
<div class="section" id="model">
<h2>Model<a class="headerlink" href="#model" title="Permalink to this headline">¬∂</a></h2>
<p>Let‚Äôs define the model that we would like to classify. Let‚Äôs start with
a simple model with two classes: a circle of radius
<span class="math notranslate nohighlight">\(r =\sqrt{2/\pi}\)</span> centered at (0,0). Data points will be
distributed in a square of length 2 centered at (0,0). The particular
choice of the circle radius implies that a random classification will
have a <span class="math notranslate nohighlight">\(\sim 50\)</span>% accuracy.</p>
<p><code class="docutils literal notranslate"><span class="pre">circle</span></code> function will have two parts: - <code class="docutils literal notranslate"><span class="pre">random</span> <span class="pre">=</span> <span class="pre">True</span></code>: generate
and label random points according to their position inside or outside
the circle (used for training) - <code class="docutils literal notranslate"><span class="pre">random</span> <span class="pre">=</span> <span class="pre">False</span></code>: computes the label
of a given point <code class="docutils literal notranslate"><span class="pre">x_input</span></code> (used for testing)</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">random</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">x_input</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        samples (int): number of samples to generate</span>
<span class="sd">        random = True: generates and labels sample random points</span>
<span class="sd">        random = False: labels x_input point</span>
<span class="sd">        x_input (array[tuple]): given point to be labeled if random = False</span>
<span class="sd">        center (tuple): center of the circle</span>
<span class="sd">        radius (float): radius of the circle</span>

<span class="sd">    Returns:</span>
<span class="sd">        if random = True:</span>
<span class="sd">            xvals (array[tuple]): data points coordinates</span>
<span class="sd">            yvals (array[int]): corresponding data labels</span>
<span class="sd">        if random = False:</span>
<span class="sd">            y (int): label of x_input point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">random</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yvals</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">random</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_input</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="section" id="target-states">
<h2>Target states<a class="headerlink" href="#target-states" title="Permalink to this headline">¬∂</a></h2>
<p>Next step is to fix the classes states. The classifier will be trained
to return these states depending on the data point. To reduce the
uncertanty, target states should be as much distanced as possible. With
a single qubit, that means to choose points in the Bloch sphere as much
separated as possible. For a two-class problem, an easy choice is
<span class="math notranslate nohighlight">\(|0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle\)</span> states.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># |0&gt; : points inside the circle</span>
<span class="c1"># |1&gt; : points outside the circle</span>
<span class="k">def</span> <span class="nf">targ_wfn</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nclass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arg:</span>
<span class="sd">        - y (int): class label</span>
<span class="sd">        - nclass: number of classes</span>
<span class="sd">    Returns:</span>
<span class="sd">        - wfn: wavefunction of the target state</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nclass</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">wfn</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">QubitWaveFunction</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">wfn</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">QubitWaveFunction</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;nclass = </span><span class="si">{}</span><span class="s2"> is not considered&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nclass</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">wfn</span>
</pre></div>
</div>
</div>
<div class="section" id="single-qubit-classifier-circuit">
<h2>Single-qubit classifier circuit<a class="headerlink" href="#single-qubit-classifier-circuit" title="Permalink to this headline">¬∂</a></h2>
<p>The single-qubit classifier has a layer structure, i.e. we have to
decide how to design one layer and then how many layers we would like to
consider. We will consider the following structure: each layer is a
collection of rotational gates which angles are a linear function of a
data point with the free parameters to be optimized. In particular,</p>
<div class="math notranslate nohighlight">
\[L\left(\vec{x};\vec{\theta}_{i}\right) = R_{z}\left(x^{2}+\theta_{i}^{2}\right) R_{y}\left(x^{1}+\theta_{i}^{1}\right).\]</div>
<p>Then, each layer adds 2 parameters to be optimized. The data points
<span class="math notranslate nohighlight">\((x^1,x^2)\)</span> are re-uploaded in each layer.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># single-qubit quantum classifier circuit</span>
<span class="k">def</span> <span class="nf">qcircuit</span><span class="p">(</span><span class="n">xval</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arg:</span>
<span class="sd">        - xval (array[tuple]): data point</span>
<span class="sd">        - param (dict): parameters dictionary</span>
<span class="sd">    Returns:</span>
<span class="sd">        - qc: quantum circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># 2 parameters/layer</span>
    <span class="c1"># initialize the circuit</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">layers</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># add layers to the circuit</span>
        <span class="n">qc</span> <span class="o">+=</span> <span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">xval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">param</span><span class="p">[</span><span class="n">p</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">tq</span><span class="o">.</span><span class="n">gates</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="n">xval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">param</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qc</span>
</pre></div>
</div>
</div>
<div class="section" id="cost-function">
<h2>Cost function<a class="headerlink" href="#cost-function" title="Permalink to this headline">¬∂</a></h2>
<p>The cost function for this quantum classifier model will be constructed
from the fidelity of the classifier final state respect to the target
state of its corresponding class. It will penalize that the output state
is far from its label state.</p>
<p>First, we define the fidelity between two states as an objective (see
State Preparation Tutorial). Then, we construct the simplest cost
function of this kind: average of squared infidelities for all training
points <span class="math notranslate nohighlight">\(M\)</span>:</p>
<div class="math notranslate nohighlight">
\[\chi^2 = \sum_{i=1}^{M}\left(1-|\langle\psi_{target}|\psi_{circuit}\rangle|^2\right)^2\]</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fidelity objective</span>
<span class="k">def</span> <span class="nf">fid</span><span class="p">(</span><span class="n">wfn_targ</span><span class="p">,</span> <span class="n">qc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arg:</span>
<span class="sd">        - wfn_targ: target wavefunction</span>
<span class="sd">        - qc : quantum circuit</span>
<span class="sd">    Returns:</span>
<span class="sd">        - O: objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho_targ</span> <span class="o">=</span>  <span class="n">tq</span><span class="o">.</span><span class="n">paulis</span><span class="o">.</span><span class="n">Projector</span><span class="p">(</span><span class="n">wfn</span><span class="o">=</span><span class="n">wfn_targ</span><span class="p">)</span>
    <span class="n">O</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">Objective</span><span class="o">.</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="n">qc</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">rho_targ</span><span class="p">)</span>
    <span class="c1"># fidelity = tq.simulate(O)</span>
    <span class="k">return</span> <span class="n">O</span>

<span class="c1"># cost function: sum of all infidelities for each data point respect the label state</span>
<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">nclass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arg:</span>
<span class="sd">        - x (array[tuple]): training points</span>
<span class="sd">        - y (array[int]): labels of training points</span>
<span class="sd">        - param (dict): parameters dictionary</span>
<span class="sd">        - nclass (int): number of classes</span>
<span class="sd">    Returns:</span>
<span class="sd">        - loss/ len(x): loss objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="c1"># M = len(y): number of training points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>

        <span class="c1"># state generated by the classifier</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">qcircuit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">param</span><span class="p">)</span>
        <span class="c1"># fidelity objective respect to the label state</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fid</span><span class="p">(</span><span class="n">targ_wfn</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nclass</span><span class="p">),</span> <span class="n">qc</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="training">
<h2>Training<a class="headerlink" href="#training" title="Permalink to this headline">¬∂</a></h2>
<div class="line-block">
<div class="line">We have now all the ingredients to train a single-qubit classifier
with data re-uploading.</div>
<div class="line">If a gradient based optimization is chosen for this type of
optimization problems, numerical gradients are adviced since
analytical ones become quite expensive.</div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">layers</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">nclass</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">training_set</span> <span class="o">=</span> <span class="mi">400</span>

<span class="c1"># generate the training set and its corresponding labels</span>
<span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">training_set</span><span class="p">)</span>

<span class="c1"># generate the variational parameters</span>
<span class="n">param</span> <span class="o">=</span> <span class="p">[</span><span class="n">tq</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;th_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">layers</span><span class="p">)]</span>

<span class="c1"># initialize the variational parameters</span>
<span class="c1"># note that due to the random initialization the result can be different from time to time</span>
<span class="c1"># With gradient based optimization you might get stuck</span>
<span class="n">inval</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span> <span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param</span><span class="p">}</span>

<span class="n">grad</span> <span class="o">=</span> <span class="s1">&#39;2-point&#39;</span> <span class="c1"># numerical gradient (= None: analytical gradient)</span>
<span class="n">mthd</span> <span class="o">=</span> <span class="s1">&#39;rmsprop&#39;</span> <span class="c1"># scipy minimization method</span>
<span class="n">mthd_opt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eps&#39;</span><span class="p">:</span><span class="mf">1.e-4</span><span class="p">}</span> <span class="c1"># method options (that&#39;s the stepsize for the gradients)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">nclass</span><span class="p">)</span> <span class="c1"># objective to be optimized: cost function</span>

<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># depending on the optimizer this will take a while</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">initial_values</span><span class="o">=</span><span class="n">inval</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">mthd</span><span class="p">,</span>
                                   <span class="n">gradient</span> <span class="o">=</span> <span class="n">grad</span><span class="p">,</span> <span class="n">method_options</span> <span class="o">=</span> <span class="n">mthd_opt</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
</pre></div>
</div>
<p>Extract the results:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;loss = &quot;</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;method: &quot;</span><span class="p">,</span> <span class="n">mthd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;method parameters: &quot;</span><span class="p">,</span> <span class="n">mthd_opt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;execution time = &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">,</span> <span class="s2">&quot; min&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;energies&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;loss&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="test">
<h2>Test<a class="headerlink" href="#test" title="Permalink to this headline">¬∂</a></h2>
<p>Once trained, we have the optimal parameters for the classifier stored
in <code class="docutils literal notranslate"><span class="pre">test.angles</span></code>. We run again the classifier with the test data set
and with these parameters fixed.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_set</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># initialize</span>
<span class="n">xval_test</span><span class="p">,</span> <span class="n">yval_test</span><span class="p">,</span> <span class="n">yval_rand</span><span class="p">,</span> <span class="n">yval_real</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="n">suc</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># success</span>
<span class="n">suc_rand</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># random success</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">test_set</span><span class="p">):</span>

    <span class="c1"># random test point</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># state generated by the trained classifier</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">qcircuit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">wfn_qc</span> <span class="o">=</span> <span class="n">tq</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="n">test</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nclass</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

        <span class="c1"># compute the fidelity respect to one of the label states, the |0&gt;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wfn_qc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">targ_wfn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nclass</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># if fidelity is &gt;= 0.5, we conclude that this state belongs to |0&gt; class</span>
        <span class="c1"># (|1&gt; class otherwise)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># check the real class of the data point</span>
        <span class="n">y_real</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">random</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">x_input</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;nclass = </span><span class="si">{}</span><span class="s2"> is not considered&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nclass</span><span class="p">))</span>

    <span class="c1"># compute success rate</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y_real</span><span class="p">:</span>
        <span class="n">suc</span> <span class="o">=</span> <span class="n">suc</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># compute random success rate</span>
    <span class="n">yrand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nclass</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yrand</span> <span class="o">==</span> <span class="n">y_real</span><span class="p">:</span>
        <span class="n">suc_rand</span> <span class="o">=</span> <span class="n">suc_rand</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">xval_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">yval_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">yval_real</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_real</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;success %: &quot;</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">suc</span><span class="o">/</span><span class="n">test_set</span><span class="p">,</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;random success %: &quot;</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">suc_rand</span><span class="o">/</span><span class="n">test_set</span><span class="p">,</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Print results:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">nclass</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arg:</span>
<span class="sd">        - x (array[tuple]): data points</span>
<span class="sd">        - y (array[int]): data labels</span>
<span class="sd">        - nclass (int): number of classes</span>
<span class="sd">    Returns:</span>
<span class="sd">        - Plot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

    <span class="c1"># colors and labels</span>
    <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">,</span><span class="s2">&quot;yellow&quot;</span><span class="p">]</span>
    <span class="n">lab</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nclass</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">lab</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">lab</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$x_1$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$x_2$&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xval_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xval_test</span><span class="p">)</span>
<span class="n">yval_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yval_test</span><span class="p">)</span>
<span class="n">yval_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yval_real</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="n">plot_data</span><span class="p">(</span><span class="n">xval_test</span><span class="p">,</span> <span class="n">yval_test</span><span class="p">,</span> <span class="n">nclass</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plot_data</span><span class="p">(</span><span class="n">xval_test</span><span class="p">,</span> <span class="n">yval_real</span><span class="p">,</span> <span class="n">nclass</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Single-qubit class. </span><span class="si">{}</span><span class="s2"> layers&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">layers</span><span class="p">))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;True test data&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total execution time: &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">t2</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">,</span><span class="s2">&quot; min.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="improvements-and-customization">
<h2>Improvements and customization<a class="headerlink" href="#improvements-and-customization" title="Permalink to this headline">¬∂</a></h2>
<p>This tutorial just shows a simple classification example. It is
constructed in a way that one can easily change the classification model
and try more sophisticated problems comprising more classes. To do so,
one should define the target states for &gt;2 classes, i.e. include more
vectors in the Bloch sphere.</p>
<p>The single-qubit classifier circuit can also be modified to include
higher dimensional data or to increase/reduce the number of parameters
per layer.</p>
<p>The cost function can also be improved. See for instance the weigthed
fidelity cost function proposed in the main reference.</p>
<p>Finally, the core of any variational algorithm is the minimization
method. Tequila provides many methods besides the scipy ones. See the
<a class="reference external" href="https://github.com/aspuru-guzik-group/tequila/blob/master/tutorials/Optimizer_Tutorial.ipynb">optimizers
tutorial</a>
for more information. Notice also that the algorithm starts with a
random initialization. It is well-known that random initialization in
variational circuits leads to a barren-plateaus problem when computing
the gradients. This problem can be avoided by providing a good
initialization guess.</p>
<p>Another possibility to play with expoloiting other Tequila modules is to
use Phoenics for initial exploration and a gradient based optimizer with
the best Phoenics results as starting point (see Phoenics
documentation).</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020, Matter Lab.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>