<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tequila.quantumchemistry.qc_base &#8212; tequila XXXXX documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          Tequila</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../.././tequila_presentation.html">Overview</a></li>
                <li><a href="../../.././install.html">Installation</a></li>
                <li><a href="../../.././package/index.html">API</a></li>
                <li><a href="https://github.com/aspuru-guzik-group/tequila">GitHub</a></li>
                <li><a href="../../.././tutorials.html">Tutorials</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html">Tequila</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#quantum-backends">Quantum Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#quantumchemistry">QuantumChemistry:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#getting-started">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#dependencies">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#documentation">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html#troubleshooting">Troubleshooting</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../package/index.html">Tequila Library Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for tequila.quantumchemistry.qc_base</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">tequila</span> <span class="kn">import</span> <span class="n">TequilaException</span><span class="p">,</span> <span class="n">BitString</span><span class="p">,</span> <span class="n">TequilaWarning</span>
<span class="kn">from</span> <span class="nn">tequila.hamiltonian</span> <span class="kn">import</span> <span class="n">QubitHamiltonian</span>

<span class="kn">from</span> <span class="nn">tequila.circuit</span> <span class="kn">import</span> <span class="n">QCircuit</span><span class="p">,</span> <span class="n">gates</span>
<span class="kn">from</span> <span class="nn">tequila.objective.objective</span> <span class="kn">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">Variables</span><span class="p">,</span> <span class="n">ExpectationValue</span>

<span class="kn">from</span> <span class="nn">tequila.simulators.simulator_api</span> <span class="kn">import</span> <span class="n">simulate</span>
<span class="kn">from</span> <span class="nn">tequila.utils</span> <span class="kn">import</span> <span class="n">to_float</span>

<span class="kn">import</span> <span class="nn">typing</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">openfermion</span>
<span class="kn">from</span> <span class="nn">openfermion.hamiltonians</span> <span class="kn">import</span> <span class="n">MolecularData</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<span class="k">def</span> <span class="nf">prepare_product_state</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">BitString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QCircuit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Small convenience function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    state :</span>
<span class="sd">        product state encoded into a bitstring</span>
<span class="sd">    state: BitString :</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    type</span>
<span class="sd">        unitary circuit which prepares the product state</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ParametersQC</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Specialization of ParametersHamiltonian&quot;&quot;&quot;</span>
    <span class="n">basis_set</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># Quantum chemistry basis set</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># geometry of the underlying molecule (units: Angstrom!),</span>
    <span class="c1"># this can be a filename leading to an .xyz file or the geometry given as a string</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">multiplicity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">charge</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">closed_shell</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;molecule&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_set</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">molecular_data_param</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:return: Give back all parameters for the MolecularData format from openfermion as dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_set</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_geometry</span><span class="p">(),</span> <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                <span class="s1">&#39;charge&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge</span><span class="p">,</span> <span class="s1">&#39;multiplicity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
                <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">format_element_name</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;OpenFermion uses case sensitive hash tables for chemical elements</span>
<span class="sd">        I.e. you need to name Lithium: &#39;Li&#39; and &#39;li&#39; or &#39;LI&#39; will not work</span>
<span class="sd">        this convenience function does the naming</span>
<span class="sd">        :return: first letter converted to upper rest to lower</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        string :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
        <span class="n">fstring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fstring</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_to_list</span><span class="p">(</span><span class="n">geometry</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a molecular structure given as a string into a list suitable for openfermion</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry :</span>
<span class="sd">            a string specifying a mol. structure. E.g. geometry=&quot;h 0.0 0.0 0.0\n h 0.0 0.0 1.0&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            A list with the correct format for openfermion E.g return [ [&#39;h&#39;,[0.0,0.0,0.0], [..]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">geometry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>  <span class="k">break</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ParametersQC</span><span class="o">.</span><span class="n">format_element_name</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                       <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;get_geometry list unknown line:</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> proceed with caution!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">get_geometry_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;returns the geometry as a string</span>
<span class="sd">        :return: geometry string</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span>
            <span class="n">geomstring</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_xyz_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">comment</span>
            <span class="k">return</span> <span class="n">geomstring</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

    <span class="k">def</span> <span class="nf">get_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the geometry</span>
<span class="sd">        If a xyz filename was given the file is read out</span>
<span class="sd">        otherwise it is assumed that the geometry was given as string</span>
<span class="sd">        which is then reformatted as a list usable as input for openfermion</span>
<span class="sd">        :return: geometry as list</span>
<span class="sd">        e.g. [(h,(0.0,0.0,0.35)),(h,(0.0,0.0,-0.35))]</span>
<span class="sd">        Units: Angstrom!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span>
            <span class="n">geomstring</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_xyz_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">comment</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;molecule&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_list</span><span class="p">(</span><span class="n">geomstring</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Parameters.qc.geometry is None&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read_xyz_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read XYZ filetype for molecular structures</span>
<span class="sd">        https://en.wikipedia.org/wiki/XYZ_file_format</span>
<span class="sd">        Units: Angstrom!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename :</span>
<span class="sd">            return:</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="n">natoms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">):</span>
                <span class="n">coord</span> <span class="o">+=</span> <span class="n">content</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">coord</span><span class="p">,</span> <span class="n">comment</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ClosedShellAmplitudes</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
    <span class="n">tIjAb</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tIA</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">make_parameter_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold :</span>
<span class="sd">             (Default value = 1.e-8)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nvirt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nocc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">nvirt</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">nocc</span> <span class="o">+</span> <span class="n">B</span><span class="p">,</span> <span class="n">J</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIA</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIA</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="n">A</span> <span class="o">+</span> <span class="n">nocc</span><span class="p">,</span> <span class="n">I</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Amplitudes</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Coupled-Cluster Amplitudes</span>
<span class="sd">    We adopt the Psi4 notation for consistency</span>
<span class="sd">    I,A for alpha</span>
<span class="sd">    i,a for beta</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_closed_shell</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cs</span><span class="p">:</span> <span class="n">ClosedShellAmplitudes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize from closed-shell Amplitude structure</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs: ClosedShellAmplitudes :</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tijab</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">tIjAb</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ijab -&gt; ijba&quot;</span><span class="p">,</span> <span class="n">cs</span><span class="o">.</span><span class="n">tIjAb</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tIjAb</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">tIjAb</span><span class="p">,</span> <span class="n">tIA</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">tIA</span><span class="p">,</span> <span class="n">tiJaB</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">tIjAb</span><span class="p">,</span> <span class="n">tia</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">tIA</span><span class="p">,</span> <span class="n">tijab</span><span class="o">=</span><span class="n">tijab</span><span class="p">,</span> <span class="n">tIJAB</span><span class="o">=</span><span class="n">tijab</span><span class="p">)</span>

    <span class="n">tIjAb</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tIA</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tiJaB</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tijab</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tIJAB</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tia</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">make_parameter_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold :</span>
<span class="sd">             (Default value = 1.e-8)</span>
<span class="sd">             Neglect amplitudes below the threshold</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dictionary of tequila variables (hash is in the style of (a,i,b,j))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nvirt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nocc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">nvirt</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">A</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">I</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiJaB</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">B</span><span class="p">),</span> <span class="n">J</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tijab</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tijab</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">A</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">I</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">+</span> <span class="n">B</span><span class="p">),</span> <span class="n">J</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIA</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tIjAb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tia</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nocc</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIA</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">nocc</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">I</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tIA</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">variables</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">nocc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">variables</span>


<span class="k">class</span> <span class="nc">NBodyTensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Convenience class for handling N-body tensors &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elems</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">active_indices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">scheme</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">size_full</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Set elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">elems</span>
        <span class="c1"># Active indices only as list of indices (e.g. spatial orbital indices), not as a dictionary of irreducible</span>
        <span class="c1"># representations</span>
        <span class="k">if</span> <span class="n">active_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_indices</span> <span class="o">=</span> <span class="n">active_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_passive_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Determine order of tensor</span>
        <span class="c1"># Assume, that tensor is entered in desired shape, not as flat array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Can use size_full &lt; self.elems.shape[0] -&gt; &#39;full&#39; space is to be considered a subspace as well</span>
        <span class="k">if</span> <span class="n">size_full</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_size_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_size_full</span> <span class="o">=</span> <span class="n">size_full</span>
        <span class="c1"># 2-body tensors (&lt;=&gt; order 4) currently allow reordering</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;chem&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="n">scheme</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Ordering only implemented for tensors of order 4 / 2-body tensors.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">sub_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_lists</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get subspace of tensor by a set of index lists</span>
<span class="sd">        according to hPQ.sub_lists(idx_lists=[p, q]) = [hPQ for P in p and Q in q]</span>

<span class="sd">        This essentially is an implementation of a non-contiguous slicing using numpy.take</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            idx_lists :</span>
<span class="sd">                List of lists, each defining the desired subspace per axis</span>
<span class="sd">                Size needs to match order of tensor, and lists successively correspond to axis=0,1,2,...,N</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            out :</span>
<span class="sd">                Sliced tensor as numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if index list has correct size</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_lists</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to pass an index list for each dimension!&quot;</span> <span class="o">+</span>
                            <span class="s2">&quot; Length of idx_lists needs to match order of tensor.&quot;</span><span class="p">)</span>

        <span class="c1"># Perform slicing via numpy.take</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx_lists</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># None means, we want the full space in this direction</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">idx_lists</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">set_index_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set passive and full index lists based on class inputs &quot;&quot;&quot;</span>
        <span class="n">tmp_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_full</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_full</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_passive_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp_size</span><span class="p">)</span>
                                 <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp_size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">sub_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get subspace of tensor by a string</span>
<span class="sd">        Currently is able to resolve an active space, named &#39;a&#39;, full space &#39;f&#39;, and the complement &#39;p&#39; = &#39;f&#39; - &#39;a&#39;.</span>
<span class="sd">        Full space in this context may also be smaller than actual tensor dimension.</span>

<span class="sd">        The specification of active space in this context only allows to pick a set from a list of orbitals, and</span>
<span class="sd">        is not able to resolve an active space from irreducible representations.</span>

<span class="sd">        Example for one-body tensor:</span>
<span class="sd">        hPQ.sub_lists(name=&#39;ap&#39;) = [hPQ for P in active_indices and Q in _passive_indices]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            name :</span>
<span class="sd">                String specifying the desired subspace, elements need to be a (active), f (full), p (full - active)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            out :</span>
<span class="sd">                Sliced tensor as numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_index_lists</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices_set</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No name specified.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Name does not match order of the tensor.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to set an active space in order to call this function.&quot;</span><span class="p">)</span>

        <span class="n">idx_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Parse name as string of space indices</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                <span class="n">idx_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_indices</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
                <span class="n">idx_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_passive_indices</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size_full</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">idx_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to specify a valid letter (a,p,f).&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_lists</span><span class="p">(</span><span class="n">idx_lists</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">is_openfermion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether current ordering scheme is &#39;openfermion&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;openfermion&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;of&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_chem</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether current ordering scheme is &#39;chem&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;chem&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_phys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether current ordering scheme is &#39;phys&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;phys&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;of&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to reorder tensors according to some convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to :</span>
<span class="sd">            Ordering scheme of choice.</span>
<span class="sd">            &#39;openfermion&#39;, &#39;of&#39; (default) :</span>
<span class="sd">                openfermion - ordering, corresponds to integrals of the type</span>
<span class="sd">                h^pq_rs = int p(1)* q(2)* O(1,2) r(2) s(1) (O(1,2)</span>
<span class="sd">                with operators a^pq_rs = a^p a^q a_r a_s (a^p == a^dagger_p)</span>
<span class="sd">                currently needed for dependencies on openfermion-library</span>
<span class="sd">            &#39;chem&#39;, &#39;c&#39; :</span>
<span class="sd">                quantum chemistry ordering, collect particle terms,</span>
<span class="sd">                more convenient for real-space methods</span>
<span class="sd">                h^pq_rs = int p(1) q(1) O(1,2) r(2) s(2)</span>
<span class="sd">                This is output by psi4</span>
<span class="sd">            &#39;phys&#39;, &#39;p&#39; :</span>
<span class="sd">                typical physics ordering, integrals of type</span>
<span class="sd">                h^pq_rs = int p(1)* q(2)* O(1,2) r(1) s(2)</span>
<span class="sd">                with operators a^pq_rs = a^p a^q a_s a_r</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Reordering currently only implemented for two-body tensors.&#39;</span><span class="p">)</span>
        <span class="n">to</span> <span class="o">=</span> <span class="n">to</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_chem</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;chem&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;openfermion&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;of&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;psqr -&gt; pqrs&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;openfermion&#39;</span>
            <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;phys&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;prqs -&gt; pqrs&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;phys&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_openfermion</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;chem&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pqrs -&gt; psqr&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;chem&#39;</span>
            <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;openfermion&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;of&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;phys&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pqrs -&gt; pqsr&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;phys&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_phys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;chem&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pqrs -&gt; prqs&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;chem&#39;</span>
            <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;openfermion&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;of&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;pqsr -&gt; pqrs&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="s1">&#39;openfermion&#39;</span>
            <span class="k">elif</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;phys&#39;</span> <span class="ow">or</span> <span class="n">to</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
                <span class="k">pass</span>


<span class="k">class</span> <span class="nc">QuantumChemistryBase</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_QubitEncoding</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small wrapper class for the Qubit Transformation</span>
<span class="sd">        Provides more controlled output and handles special cases</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trafo</span> <span class="o">=</span> <span class="n">transformation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">errlog</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># return self._trafo(op, **self._kwargs)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trafo</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">E</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;converting to interaction operator&quot;</span><span class="p">)</span>
                    <span class="n">errlog</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trafo</span><span class="p">(</span><span class="n">openfermion</span><span class="o">.</span><span class="n">get_interaction_operator</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">E</span><span class="p">:</span>
                <span class="n">errlog</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Error in QubitEncoding &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">errlog</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;transformation=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trafo</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">additional keys: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;transformation=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trafo</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">ParametersQC</span><span class="p">,</span>
                 <span class="n">transformation</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">active_orbitals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">reference</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>

        <span class="k">if</span> <span class="s2">&quot;molecule&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;molecule&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_molecule</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">basis_set</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">multiplicity</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">charge</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">active_orbitals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_active_space_data</span><span class="p">(</span><span class="n">active_orbitals</span><span class="o">=</span><span class="n">active_orbitals</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_transformation</span><span class="p">(</span><span class="n">transformation</span><span class="o">=</span><span class="n">transformation</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># filter out arguments to the transformation</span>
        <span class="n">trafo_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                      <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;transformation__&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">())}</span>

        <span class="k">if</span> <span class="n">transformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">jordan_wigner</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">transformation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;jordan-wigner&quot;</span><span class="p">,</span> <span class="s2">&quot;jw&quot;</span><span class="p">,</span> <span class="s2">&quot;j-w&quot;</span><span class="p">,</span>
                                                                             <span class="s2">&quot;jordanwigner&quot;</span><span class="p">]:</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">jordan_wigner</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">transformation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bravyi-kitaev&quot;</span><span class="p">,</span> <span class="s2">&quot;bk&quot;</span><span class="p">,</span> <span class="s2">&quot;b-k&quot;</span><span class="p">,</span>
                                                                             <span class="s2">&quot;bravyikitaev&quot;</span><span class="p">]:</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">bravyi_kitaev</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">transformation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bravyi-kitaev-tree&quot;</span><span class="p">,</span> <span class="s2">&quot;bkt&quot;</span><span class="p">,</span>
                                                                             <span class="s2">&quot;bravykitaevtree&quot;</span><span class="p">,</span> <span class="s2">&quot;b-k-t&quot;</span><span class="p">]:</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">bravyi_kitaev_tree</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">transformation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tapered_bravyi_kitaev&quot;</span><span class="p">,</span> <span class="s2">&quot;tbk&quot;</span><span class="p">,</span> <span class="s2">&quot;t-b-k&quot;</span><span class="p">,</span>
                                                                             <span class="s2">&quot;symmetry_conserving_bravyi_kitaev&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s2">&quot;active_orbitals&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trafo_args</span><span class="p">:</span>
                <span class="n">trafo_args</span><span class="p">[</span><span class="s2">&quot;active_orbitals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="s2">&quot;active_fermions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trafo_args</span><span class="p">:</span>
                <span class="n">trafo_args</span><span class="p">[</span><span class="s2">&quot;active_fermions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;trafo_args = &quot;</span><span class="p">,</span> <span class="n">trafo_args</span><span class="p">)</span>
            <span class="c1"># trafo = openfermion.symmetry_conserving_bravyi_kitaev</span>
            <span class="c1"># Current hotfix, to be changed once it works again straightforward with OpenFermion</span>
            <span class="kn">from</span> <span class="nn">._openfermion_symmetry_conserving_bk_hotfix</span> <span class="kn">import</span> <span class="n">symmetry_conserving_bravyi_kitaev_HOTFIX</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="n">symmetry_conserving_bravyi_kitaev_HOTFIX</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">openfermion</span><span class="p">,</span> <span class="n">transformation</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">transformation</span><span class="p">))</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="n">transformation</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_QubitEncoding</span><span class="p">(</span><span class="n">transformation</span><span class="o">=</span><span class="n">trafo</span><span class="p">,</span> <span class="o">**</span><span class="n">trafo_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_active_space_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">active_orbitals</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Small helper function</span>
<span class="sd">        Internal use only</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        active_orbitals: dictionary :</span>
<span class="sd">            list: Give a list of spatial orbital indices</span>
<span class="sd">            i.e. occ = [0,1,3] means that spatial orbital 0, 1 and 3 are used</span>
<span class="sd">        reference: (Default value=None)</span>
<span class="sd">            List of orbitals which form the reference</span>
<span class="sd">            Can be given in the same format as active_orbitals</span>
<span class="sd">            If given as None then the first N_electron/2 orbitals are taken</span>
<span class="sd">            for closed-shell systems.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataclass with active indices and reference indices (in spatial notation)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">active_orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="nd">@dataclass</span>
        <span class="k">class</span> <span class="nc">ActiveSpaceData</span><span class="p">:</span>
            <span class="n">active_orbitals</span><span class="p">:</span> <span class="nb">list</span>  <span class="c1"># active orbitals (spatial, c1)</span>
            <span class="n">reference_orbitals</span><span class="p">:</span> <span class="nb">list</span>  <span class="c1"># reference orbitals (spatial, c1)</span>

            <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;Active Space Data:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;active_orbitals&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;reference_orbitals&quot;</span><span class="p">,</span>
                                                            <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;frozen_docc&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frozen_docc</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;frozen_uocc&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frozen_uocc</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="nd">@property</span>
            <span class="k">def</span> <span class="nf">frozen_reference_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">]</span>

            <span class="nd">@property</span>
            <span class="k">def</span> <span class="nf">active_reference_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># auto assignment only for closed-shell</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">reference</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">ActiveSpaceData</span><span class="p">(</span><span class="n">active_orbitals</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">active_orbitals</span><span class="p">),</span>
                               <span class="n">reference_orbitals</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_openfermion</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">MolecularData</span><span class="p">,</span>
                         <span class="n">transformation</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize direclty from openfermion MolecularData object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The openfermion molecule</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The Tequila molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">ParametersQC</span><span class="p">(</span><span class="n">basis_set</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                                  <span class="n">description</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">,</span>
                                  <span class="n">charge</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="n">transformation</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_excitation_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">QubitHamiltonian</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notes</span>
<span class="sd">        ----------</span>
<span class="sd">        Creates the transformed hermitian generator of UCC type unitaries:</span>
<span class="sd">              M(a^\dagger_{a_0} a_{i_0} a^\dagger{a_1}a_{i_1} ... - h.c.)</span>
<span class="sd">              where the qubit map M depends is self.transformation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : typing.Iterable[typing.Tuple[int, int]] :</span>
<span class="sd">            List of tuples [(a_0, i_0), (a_1, i_1), ... ] - recommended format, in spin-orbital notation (alpha odd numbers, beta even numbers)</span>
<span class="sd">            can also be given as one big list: [a_0, i_0, a_1, i_1 ...]</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            1j*Transformed qubit excitation operator, depends on self.transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">_trafo</span> <span class="o">==</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">bravyi_kitaev_fast</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;The Bravyi-Kitaev-Superfast transformation does not support general FermionOperators yet&quot;</span><span class="p">)</span>

        <span class="c1"># check indices and convert to list of tuples if necessary</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_excitation_operator: no indices given&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_excitation_generator: unexpected input format of indices</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;use list of tuples as [(a_0, i_0),(a_1, i_1) ...]</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;or list as [a_0, i_0, a_1, i_1, ... ]</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;you gave: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="p">[(</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="c1"># convert to openfermion input format</span>
        <span class="n">ofi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ofi</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)]</span>  <span class="c1"># openfermion does not take other types of integers like numpy.int64</span>
            <span class="n">dag</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ofi</span><span class="p">),</span> <span class="mf">1.</span><span class="n">j</span><span class="p">)</span>  <span class="c1"># 1j makes it hermitian</span>
        <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">dag</span><span class="p">)),</span> <span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">)</span>
        <span class="n">qop</span> <span class="o">=</span> <span class="n">QubitHamiltonian</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
        <span class="c1"># check if the operator is hermitian and cast coefficients to floats</span>
        <span class="c1"># in order to avoid trouble with the simulation backends</span>
        <span class="k">assert</span> <span class="n">qop</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qop</span><span class="o">.</span><span class="n">qubit_operator</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">qop</span><span class="o">.</span><span class="n">qubit_operator</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">qop</span> <span class="o">=</span> <span class="n">qop</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Excitation generator is a unit operator.</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="s2">&quot;Non-standard transformations might not work with general fermionic operators</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="s2">&quot;indices = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">category</span><span class="o">=</span><span class="n">TequilaWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qop</span>

    <span class="k">def</span> <span class="nf">reference_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_orbitals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BitString</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Does a really lazy workaround ... but it works</span>
<span class="sd">        :return: Hartree-Fock Reference as binary-number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_orbitals: list:</span>
<span class="sd">            give list of doubly occupied orbitals</span>
<span class="sd">            default is None which leads to automatic list of the</span>
<span class="sd">            first n_electron/2 orbitals</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n_qubits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">_trafo</span> <span class="o">==</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">symmetry_conserving_bravyi_kitaev</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">tapering</span><span class="p">(</span><span class="n">fop</span><span class="p">):</span>
                <span class="n">fermion_hamiltonian_reorder</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">fop</span><span class="p">,</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">,</span>
                                                                        <span class="n">num_modes</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">)</span>
                <span class="n">qubit_hamiltonian</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">bravyi_kitaev_tree</span><span class="p">(</span><span class="n">fermion_hamiltonian_reorder</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">)</span>
                <span class="n">qubit_hamiltonian</span><span class="o">.</span><span class="n">compress</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">qubit_hamiltonian</span>

            <span class="n">transformation</span> <span class="o">=</span> <span class="n">tapering</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">_trafo</span> <span class="o">==</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">bravyi_kitaev_fast</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;The Bravyi-Kitaev-Superfast transformation does not support general FermionOperators yet&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span>

        <span class="k">if</span> <span class="n">reference_orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span>

        <span class="n">spin_orbitals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reference_orbitals</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reference_orbitals</span><span class="p">])</span>

        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;1.0 [&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spin_orbitals</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;^ &quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;]&quot;</span>

        <span class="n">fop</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">QubitHamiltonian</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="o">=</span><span class="n">transformation</span><span class="p">(</span><span class="n">fop</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">tequila.wavefunction.qubit_wavefunction</span> <span class="kn">import</span> <span class="n">QubitWaveFunction</span>
        <span class="n">wfn</span> <span class="o">=</span> <span class="n">QubitWaveFunction</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">)</span>
        <span class="n">wfn</span> <span class="o">=</span> <span class="n">wfn</span><span class="o">.</span><span class="n">apply_qubitoperator</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">op</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wfn</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">wfn</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">_trafo</span> <span class="o">==</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">symmetry_conserving_bravyi_kitaev</span><span class="p">:</span>
            <span class="n">active_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_qubits</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">active_qubits</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">BitString</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">make_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MolecularData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a molecule in openfermion format by running psi4 and extracting the data</span>
<span class="sd">        Will check for previous outputfiles before running</span>
<span class="sd">        Will not recompute if a file was found</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters :</span>
<span class="sd">            An instance of ParametersQC, which also holds an instance of ParametersPsi4 via parameters.psi4</span>
<span class="sd">            The molecule will be saved in parameters.filename, if this file exists before the call the molecule will be imported from the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            the molecule in openfermion.MolecularData format</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">molecular_data_param</span><span class="p">)</span>
        <span class="c1"># try to load</span>

        <span class="n">do_compute</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">os</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
                <span class="n">molecule</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
                <span class="n">do_compute</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="n">do_compute</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">do_compute</span><span class="p">:</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_make_molecule</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">molecule</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">do_make_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># integrals need to be passed in base class</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;one_body_integrals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;two_body_integrals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">one_body_integrals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;one_body_integrals&quot;</span><span class="p">]</span>
        <span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;two_body_integrals&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;nuclear_repulsion&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">nuclear_repulsion</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nuclear_repulsion&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nuclear_repulsion</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No nuclear_repulsion given for custom molecule, setting to zero&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">TequilaWarning</span><span class="p">)</span>


        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;n_orbitals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">n_orbitals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_orbitals&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_orbitals</span> <span class="o">=</span> <span class="n">one_body_integrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="n">n_orbitals</span> <span class="o">==</span> <span class="n">two_body_integrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">molecular_data_param</span><span class="p">)</span>

        <span class="n">molecule</span><span class="o">.</span><span class="n">one_body_integrals</span> <span class="o">=</span> <span class="n">one_body_integrals</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">two_body_integrals</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion</span> <span class="o">=</span> <span class="n">nuclear_repulsion</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">=</span> <span class="n">n_orbitals</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_space</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">n_electrons</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_space</span><span class="o">.</span><span class="n">active_reference_orbitals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">occupied_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QubitHamiltonian</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">occupied_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">occupied_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span><span class="o">.</span><span class="n">frozen_reference_orbitals</span>
        <span class="k">if</span> <span class="n">active_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">active_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_space</span><span class="o">.</span><span class="n">active_orbitals</span>

        <span class="n">fop</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">get_fermion_operator</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">get_molecular_hamiltonian</span><span class="p">(</span><span class="n">occupied_indices</span><span class="p">,</span> <span class="n">active_indices</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">qop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">fop</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">qop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">openfermion</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">get_interaction_operator</span><span class="p">(</span><span class="n">fop</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">QubitHamiltonian</span><span class="p">(</span><span class="n">qubit_hamiltonian</span><span class="o">=</span><span class="n">qop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_one_body_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;molecule&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">one_body_integrals</span>

    <span class="k">def</span> <span class="nf">compute_two_body_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;molecule&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">two_body_integrals</span>

    <span class="k">def</span> <span class="nf">compute_ccsd_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClosedShellAmplitudes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;BaseClass Method&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tequila circuit object which prepares the reference of this molecule in the chosen transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">prepare_product_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_state</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_upccgsd_ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">include_singles</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">include_reference</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">indices</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">order</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        UpGCCSD Ansatz similar as described by Lee et. al.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_singles</span>
<span class="sd">            include singles excitations</span>
<span class="sd">        include_reference</span>
<span class="sd">            include the HF reference state as initial state</span>
<span class="sd">        indices</span>
<span class="sd">            pass custom defined set of indices from which the ansatz will be created</span>
<span class="sd">            List of tuples of tuples spin-indices e.g. [((2*p,2*q),(2*p+1,2*q+1)), ...]</span>
<span class="sd">        label</span>
<span class="sd">            An additional label that is set with the variables</span>
<span class="sd">            default is None and no label will be set: variables names will be</span>
<span class="sd">            (x, (p,q)) for x in range(order)</span>
<span class="sd">            with a label the variables will be named</span>
<span class="sd">            (label, (x, (p,q))) </span>
<span class="sd">        order</span>
<span class="sd">            Order of the ansatz (default is 1)</span>
<span class="sd">            determines how often the ordering gets repeated</span>
<span class="sd">            parameters of repeating layers are independent</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            UpGCCSD ansatz</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># indices defining the UpCCD ansatz</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">):</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="n">include_singles</span><span class="p">:</span>
                        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)))</span>
                        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include_reference</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_reference</span><span class="p">()</span>

        <span class="n">generators</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_generator</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">order</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">Trotterized</span><span class="p">(</span><span class="n">generators</span><span class="o">=</span><span class="n">generators</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">U</span>

    <span class="k">def</span> <span class="nf">make_uccsd_ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trotter_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                          <span class="n">initial_amplitudes</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Amplitudes</span><span class="p">,</span> <span class="n">ClosedShellAmplitudes</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mp2&quot;</span><span class="p">,</span>
                          <span class="n">include_reference_ansatz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">parametrized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">,</span>
                          <span class="n">trotter_parameters</span><span class="p">:</span> <span class="n">gates</span><span class="o">.</span><span class="n">TrotterParameters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QCircuit</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_amplitudes :</span>
<span class="sd">            initial amplitudes given as ManyBodyAmplitudes structure or as string</span>
<span class="sd">            where &#39;mp2&#39;, &#39;cc2&#39; or &#39;ccsd&#39; are possible initializations</span>
<span class="sd">        include_reference_ansatz :</span>
<span class="sd">            Also do the reference ansatz (prepare closed-shell Hartree-Fock) (Default value = True)</span>
<span class="sd">        parametrized :</span>
<span class="sd">            Initialize with variables, otherwise with static numbers (Default value = True)</span>
<span class="sd">        trotter_steps: int :</span>

<span class="sd">        initial_amplitudes: typing.Union[str :</span>

<span class="sd">        Amplitudes :</span>

<span class="sd">        ClosedShellAmplitudes] :</span>
<span class="sd">             (Default value = &quot;mp2&quot;)</span>
<span class="sd">        trotter_parameters: gates.TrotterParameters :</span>
<span class="sd">             (Default value = None)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            Parametrized QCircuit</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_uccsd_ansatz currently only for closed shell systems&quot;</span><span class="p">)</span>

        <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">nvirt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">nocc</span>

        <span class="n">Uref</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include_reference_ansatz</span><span class="p">:</span>
            <span class="n">Uref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_reference</span><span class="p">()</span>

        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">initial_amplitudes</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">initial_amplitudes</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mp2&quot;</span><span class="p">:</span>
                <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mp2_amplitudes</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ccsd&quot;</span><span class="p">:</span>
                <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_ccsd_amplitudes</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_amplitudes</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">Don&#39;t know how to initialize </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s2"> amplitudes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">initial_amplitudes</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">amplitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">ClosedShellAmplitudes</span><span class="p">(</span>
                <span class="n">tIjAb</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">nocc</span><span class="p">,</span> <span class="n">nocc</span><span class="p">,</span> <span class="n">nvirt</span><span class="p">,</span> <span class="n">nvirt</span><span class="p">]),</span>
                <span class="n">tIA</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">nocc</span><span class="p">,</span> <span class="n">nvirt</span><span class="p">]))</span>

        <span class="n">closed_shell</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span> <span class="n">ClosedShellAmplitudes</span><span class="p">)</span>
        <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">amplitudes</span><span class="o">.</span><span class="n">make_parameter_dictionary</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
            <span class="n">amplitudes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">amplitudes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">amplitudes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">closed_shell</span><span class="p">:</span>
                    <span class="n">spin_indices</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">spin_indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                        <span class="n">partner</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">spin_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
                        <span class="n">spin_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                            <span class="n">spin_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
                            <span class="n">spin_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">partner</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>  <span class="c1"># taibj -&gt; tbiaj</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">spin_indices</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
                        <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_generator</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">idx</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">parametrized</span><span class="p">:</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>  <span class="c1"># abab</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>  <span class="c1"># baba</span>
                        <span class="k">if</span> <span class="n">partner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span> <span class="o">-</span> <span class="n">Variable</span><span class="p">(</span><span class="n">partner</span><span class="p">))</span>  <span class="c1"># aaaa</span>
                            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span> <span class="o">-</span> <span class="n">Variable</span><span class="p">(</span><span class="n">partner</span><span class="p">))</span>  <span class="c1"># bbbb</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">partner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">amplitudes</span><span class="p">[</span><span class="n">partner</span><span class="p">])</span>
                            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">amplitudes</span><span class="p">[</span><span class="n">partner</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_operator</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">spin_indices</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">parametrized</span><span class="p">:</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Uref</span> <span class="o">+</span> <span class="n">gates</span><span class="o">.</span><span class="n">Trotterized</span><span class="p">(</span><span class="n">generators</span><span class="o">=</span><span class="n">generators</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">trotter_steps</span><span class="p">,</span>
                                        <span class="n">parameters</span><span class="o">=</span><span class="n">trotter_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute closed-shell CC amplitudes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method :</span>
<span class="sd">            coupled-cluster methods like cc2, ccsd, cc3, ccsd(t)</span>
<span class="sd">            Success might depend on backend</span>
<span class="sd">            got an extra function for MP2</span>
<span class="sd">        *args :</span>

<span class="sd">        **kwargs :</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;compute amplitudes: Needs to be overwritten by backend&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_mp2_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClosedShellAmplitudes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Compute closed-shell mp2 amplitudes</span>

<span class="sd">        .. math::</span>
<span class="sd">            t(a,i,b,j) = 0.25 * g(a,i,b,j)/(e(i) + e(j) -a(i) - b(j) )</span>

<span class="sd">        :return:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">closed_shell</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">two_body_integrals</span>
        <span class="n">fij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">orbital_energies</span>
        <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># this is never the active space</span>
        <span class="n">ei</span> <span class="o">=</span> <span class="n">fij</span><span class="p">[:</span><span class="n">nocc</span><span class="p">]</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="n">fij</span><span class="p">[</span><span class="n">nocc</span><span class="p">:]</span>
        <span class="n">abgij</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">nocc</span><span class="p">:,</span> <span class="n">nocc</span><span class="p">:,</span> <span class="p">:</span><span class="n">nocc</span><span class="p">,</span> <span class="p">:</span><span class="n">nocc</span><span class="p">]</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">abgij</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">ei</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ei</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ai</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ai</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">E</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abij,abij-&gt;&#39;</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">abgij</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abji,abij&#39;</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">abgij</span><span class="p">,</span>
                                                                                <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">mp2_energy</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">hf_energy</span>
        <span class="k">return</span> <span class="n">ClosedShellAmplitudes</span><span class="p">(</span><span class="n">tIjAb</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abij -&gt; ijab&#39;</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">compute_cis_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the CIS amplitudes of the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@dataclass</span>
        <span class="k">class</span> <span class="nc">ResultCIS</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
            <span class="n">omegas</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span>  <span class="c1"># excitation energies [omega0, ...]</span>
            <span class="n">amplitudes</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">ClosedShellAmplitudes</span><span class="p">]</span>  <span class="c1"># corresponding amplitudes [x_{ai}_0, ...]</span>

            <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitudes</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>

            <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">two_body_integrals</span>
        <span class="n">fij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecule</span><span class="o">.</span><span class="n">orbital_energies</span>

        <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_alpha_electrons</span>
        <span class="n">nvirt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">-</span> <span class="n">nocc</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nocc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nocc</span><span class="p">,</span> <span class="n">nocc</span> <span class="o">+</span> <span class="n">nvirt</span><span class="p">):</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">xx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">eia</span> <span class="o">=</span> <span class="n">fij</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">fij</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">for</span> <span class="n">yy</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">y</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">gpart</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">]</span> <span class="o">=</span> <span class="n">eia</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">gpart</span>

        <span class="n">omega</span><span class="p">,</span> <span class="n">xvecs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># convert amplitudes to ndarray sorted by excitation energy</span>
        <span class="n">nex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nex</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">nvirt</span><span class="p">,</span> <span class="n">nocc</span><span class="p">])</span>
            <span class="n">exvec</span> <span class="o">=</span> <span class="n">xvecs</span><span class="p">[</span><span class="n">ex</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">xx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">t</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="n">nocc</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exvec</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span>
            <span class="n">amplitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ClosedShellAmplitudes</span><span class="p">(</span><span class="n">tIA</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ResultCIS</span><span class="p">(</span><span class="n">omegas</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">amplitudes</span><span class="o">=</span><span class="n">amplitudes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rdm1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1-RDM has not been computed. Return None for 1-RDM.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rdm2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2-RDM has not been computed. Return None for 2-RDM.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">compute_rdms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">QCircuit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Variables</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spin_free</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">get_rdm1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">get_rdm2</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the one- and two-particle reduced density matrices (rdm1 and rdm2) given</span>
<span class="sd">        a unitary U. This method uses the standard ordering in physics as denoted below.</span>
<span class="sd">        Note, that the representation of the density matrices depends on the qubit transformation</span>
<span class="sd">        used. The Jordan-Wigner encoding corresponds to &#39;classical&#39; second quantized density</span>
<span class="sd">        matrices in the occupation picture.</span>

<span class="sd">        We only consider real orbitals and thus real-valued RDMs.</span>
<span class="sd">        The matrices are set as private members _rdm1, _rdm2 and can be accessed via the properties rdm1, rdm2.</span>

<span class="sd">        .. math :</span>
<span class="sd">            \\text{rdm1: } \\gamma^p_q = \\langle \\psi | a^p a_q | \\psi \\rangle</span>
<span class="sd">                                     = \\langle U 0 | a^p a_q | U 0 \\rangle</span>
<span class="sd">            \\text{rdm2: } \\gamma^{pq}_{rs} = \\langle \\psi | a^p a^q a_s a_r | \\psi \\rangle</span>
<span class="sd">                                             = \\langle U 0 | a^p a^q a_s a_r | U 0 \\rangle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        U :</span>
<span class="sd">            Quantum Circuit to achieve the desired state \\psi = U |0\\rangle, non-optional</span>
<span class="sd">        variables :</span>
<span class="sd">            If U is parametrized, then need to hand over a set of fixed variables</span>
<span class="sd">        spin_free :</span>
<span class="sd">            Set whether matrices should be spin-free (summation over spin) or defined by spin-orbitals</span>
<span class="sd">        get_rdm1, get_rdm2 :</span>
<span class="sd">            Set whether either one or both rdm1, rdm2 should be computed. If both are needed at some point,</span>
<span class="sd">            it is recommended to compute them at once.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check whether unitary circuit is not 0</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s1">&#39;Need to specify a Quantum Circuit.&#39;</span><span class="p">)</span>

        <span class="c1"># Check whether transformation is BKSF.</span>
        <span class="c1"># Issue here: when a single operator acts only on a subset of qubits, BKSF might not yield the correct</span>
        <span class="c1"># transformation, because it computes the number of qubits incorrectly in this case.</span>
        <span class="c1"># A hotfix such as for symmetry_conserving_bravyi_kitaev would require deeper changes, thus omitted for now</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">_trafo</span> <span class="o">==</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">bravyi_kitaev_fast</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;The Bravyi-Kitaev-Superfast transformation does not support general FermionOperators yet.&quot;</span><span class="p">)</span>

        <span class="c1"># Set up number of spin-orbitals and molecular orbitals respectively</span>
        <span class="n">n_SOs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="n">n_MOs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>

        <span class="c1"># Check whether unitary circuit is not 0</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s1">&#39;Need to specify a Quantum Circuit.&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_of_op</span><span class="p">(</span><span class="n">operator_tuple</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Returns operator given by a operator tuple as OpenFermion - Fermion operator &quot;&quot;&quot;</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">operator_tuple</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">op</span>

        <span class="k">def</span> <span class="nf">_get_qop_hermitian</span><span class="p">(</span><span class="n">of_operator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QubitHamiltonian</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns Hermitian part of Fermion operator as QubitHamiltonian &quot;&quot;&quot;</span>
            <span class="n">qop</span> <span class="o">=</span> <span class="n">QubitHamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">of_operator</span><span class="p">))</span>
            <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="n">qop</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">real</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">real</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">of_operator</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Qubit Hamiltonian does not have a Hermitian part. Check this...&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_build_1bdy_operators_spinful</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns spinful one-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetry pq = qp</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span> <span class="nf">_build_2bdy_operators_spinful</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns spinful two-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetries pqrs = -pqsr = -qprs = qpsr</span>
            <span class="c1">#                and      =  rspq</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span>
                                <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                                <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                                <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span> <span class="nf">_build_1bdy_operators_spinfree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns spinfree one-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetry pq = qp (not changed by spin-summation)</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Spin aa</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin bb</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span> <span class="nf">_build_2bdy_operators_spinfree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns spinfree two-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetries pqrs = qpsr (due to spin summation, &#39;-pqsr = -qprs&#39; drops out)</span>
            <span class="c1">#                and      = rspq</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">s</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">):</span>
                    <span class="c1"># Spin aaaa</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="n">q</span> <span class="ow">and</span> <span class="n">r</span><span class="o">!=</span><span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin abab</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">!=</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">!=</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin baba</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">!=</span><span class="mi">2</span><span class="o">*</span><span class="n">q</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">!=</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin bbbb</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="n">q</span> <span class="ow">and</span> <span class="n">r</span><span class="o">!=</span><span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>

                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span> <span class="nf">_assemble_rdm1</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns spin-ful or spin-free one-particle RDM built by symmetry conditions</span>
<span class="sd">            Same symmetry with or without spin, so we can use the same function</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">n_MOs</span> <span class="k">if</span> <span class="n">spin_free</span> <span class="k">else</span> <span class="n">n_SOs</span>
            <span class="n">rdm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">])</span>
            <span class="n">ctr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">rdm1</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                    <span class="c1"># Symmetry pq = qp</span>
                    <span class="n">rdm1</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm1</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                    <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">rdm1</span>

        <span class="k">def</span> <span class="nf">_assemble_rdm2_spinful</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns spin-ful two-particle RDM built by symmetry conditions &quot;&quot;&quot;</span>
            <span class="n">ctr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">rdm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_SOs</span><span class="p">,</span> <span class="n">n_SOs</span><span class="p">,</span> <span class="n">n_SOs</span><span class="p">,</span> <span class="n">n_SOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span>
                                <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                                <span class="c1"># Symmetry pqrs = rspq</span>
                                <span class="n">rdm2</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
                                <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Further permutational symmetries due to anticommutation relations</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                            <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># pqrs = -pqsr</span>
                            <span class="n">rdm2</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># pqrs = -qprs</span>
                            <span class="n">rdm2</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># pqrs =  qpsr</span>

            <span class="k">return</span> <span class="n">rdm2</span>

        <span class="k">def</span> <span class="nf">_assemble_rdm2_spinfree</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot; Returns spin-free two-particle RDM built by symmetry conditions &quot;&quot;&quot;</span>
            <span class="n">ctr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">rdm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">s</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">):</span>
                    <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                    <span class="c1"># Symmetry pqrs = rspq</span>
                    <span class="n">rdm2</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
                    <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Further permutational symmetry: pqrs = qpsr</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">rdm2</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">rdm2</span>

        <span class="c1"># Build operator lists</span>
        <span class="n">qops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">spin_free</span><span class="p">:</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_1bdy_operators_spinfree</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_2bdy_operators_spinfree</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_1bdy_operators_spinful</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_2bdy_operators_spinful</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="c1"># Transform operator lists to QubitHamiltonians</span>
        <span class="n">qops</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_qop_hermitian</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">qops</span><span class="p">]</span>
        <span class="c1"># Compute expected values</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">qops</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">qops</span><span class="p">)]),</span> <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># Assemble density matrices</span>
        <span class="c1"># If self._rdm1, self._rdm2 exist, reset them if they are of the other spin-type</span>
        <span class="k">def</span> <span class="nf">_reset_rdm</span><span class="p">(</span><span class="n">rdm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rdm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spin_free</span> <span class="ow">and</span> <span class="n">rdm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_MOs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">spin_free</span> <span class="ow">and</span> <span class="n">rdm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_SOs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">rdm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="o">=</span> <span class="n">_reset_rdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">_reset_rdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">)</span>
        <span class="c1"># Split expectation values in 1- and 2-particle expectation values</span>
        <span class="k">if</span> <span class="n">get_rdm1</span><span class="p">:</span>
            <span class="n">len_1</span> <span class="o">=</span> <span class="n">n_MOs</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_MOs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">spin_free</span> <span class="k">else</span> <span class="n">n_SOs</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_SOs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">len_1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">evals_1</span><span class="p">,</span> <span class="n">evals_2</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[:</span><span class="n">len_1</span><span class="p">],</span> <span class="n">evals</span><span class="p">[</span><span class="n">len_1</span><span class="p">:]</span>
        <span class="c1"># Build matrices using the expectation values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="o">=</span> <span class="n">_assemble_rdm1</span><span class="p">(</span><span class="n">evals_1</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span>
        <span class="k">if</span> <span class="n">spin_free</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">_assemble_rdm2_spinfree</span><span class="p">(</span><span class="n">evals_2</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">_assemble_rdm2_spinful</span><span class="p">(</span><span class="n">evals_2</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span>

    <span class="k">def</span> <span class="nf">rdm_spinsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_rdm1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sum_rdm2</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the spin-ful 1- and 2-particle reduced density matrices, compute the spin-free RDMs by spin summation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            sum_rdm1, sum_rdm2 :</span>
<span class="sd">               If set to true, perform spin summation on rdm1, rdm2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            rdm1_spinsum, rdm2_spinsum :</span>
<span class="sd">                The desired spin-free matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_MOs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="n">rdm1_spinsum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rdm2_spinsum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Spin summation on rdm1</span>
        <span class="k">if</span> <span class="n">sum_rdm1</span><span class="p">:</span>
            <span class="c1"># Check whether spin-rdm2 exists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The spin-RDM for the 1-RDM does not exist!&quot;</span><span class="p">)</span>
            <span class="c1"># Check whether existing rdm1 is in spin-orbital basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_MOs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The existing RDM needs to be in spin-orbital basis, it is already spin-free!&quot;</span><span class="p">)</span>
            <span class="c1"># Do summation</span>
            <span class="n">rdm1_spinsum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">]</span>
                    <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

        <span class="c1"># Spin summation on rdm2</span>
        <span class="k">if</span> <span class="n">sum_rdm2</span><span class="p">:</span>
            <span class="c1"># Check whether spin-rdm2 exists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The spin-RDM for the 2-RDM does not exist!&quot;</span><span class="p">)</span>
            <span class="c1"># Check whether existing rdm2 is in spin-orbital basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_MOs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The existing RDM needs to be in spin-orbital basis, it is already spin-free!&quot;</span><span class="p">)</span>
            <span class="c1"># Do summation</span>
            <span class="n">rdm2_spinsum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">]</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">]</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rdm1_spinsum</span><span class="p">,</span> <span class="n">rdm2_spinsum</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;Qubit Encoding</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020, Matter Lab.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>